<html>
  <head>
    <script src="//code.jquery.com/jquery-2.1.3.min.js"></script>

    <script type="text/javascript">
      var canonicalUrl = {{.CanonicalUrl}};
    </script>

    <style>
      body {
        background-color: #cccccc;
      }

      #container {
        width: 1000px;
        margin: auto;
        background-color: white;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="text/javascript">
      var sensors = {};

      function render() {
        var sortedNames = Object.keys(sensors);
        sortedNames.sort();

        var sortedSensors = [];
        for (i in sortedNames) {
          sortedSensors.push(sensors[sortedNames[i]]);
        }

        var rows = sortedSensors
          .map(function(sensor) {
            return '<tr><td>' + sensor.name + '</td><td>' + sensor.state + '</td></tr>';
          })
          .join('\n');
        var table = '<table>' + rows + '</table>';

        $('#container').empty().append(table);
      }

      if ("WebSocket" in window) {
        // WebSocket support, yay! Connect to the stream with real-time
        // updates, repaint the screen when a sensor state changes.
        var ws = new WebSocket('ws://' + canonicalUrl + '/changes');

	      ws.onerror = function() {
	        alert("WebSocket connection is broken");
	      };

	      ws.onmessage = function (evt) {
	        var data = JSON.parse(evt.data);
	        console.log(data);

          sensors[data.name] = data;
          render();
	      };

	      ws.onclose = function() {
	        alert("WebSocket connection is closed");
	      };
      } else {
        // No WebSocket support, just get the sensor states once.
        // No real-time updates here, too bad.
        $.getJSON('http://' + canonicalUrl + '/api/sensors', function(sensors_) {
          for (i in sensors_) {
            var sensor = sensors_[i];
            sensors[sensor.name] = sensor;
          }
          render();
        })
      }
    </script>
  </body>
</html>
